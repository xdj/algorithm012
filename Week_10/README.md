第一周学习了数组和链表的结构，学习了双指针，两重循环的解题思路。

第二周学习了关于利用map解题，要灵活创建key。如根据题目条件，创立26长度的int数组，数组每一位代表字母出现的次数，然后用约定符号（如#）把数组的每一位都拼接成字符串，以此字符串作为map的key。
关于树的遍历，主要是三行语句，一行导航到当前节点的左节点，一行导航到当前节点的右节点，一行读取当前节点的值。树约定俗成的遍历方法，都是先左，后右。读取当前节点值的语句所出现的位置，决定了这种遍历方法属于哪种。出现在最前，前序遍历。出现在中间，中序遍历。出现在最后，后序遍历。
树的遍历，主要有递归和迭代。个人认为，递归和迭代本质上是一致的，而递归，则是由系统内存帮我们完成了迭代的过程，把未执行到的代码压栈到内存中。

第三周学习了递归和回溯。回溯是在循环里不断地递归，主要有以下步骤：1，判断终结条件；2，执行操作，递归调用；3，撤销操作。

第四周学习了贪心算法，这是一种算法思想，并没有固定的算法模板。
还学习了二分查找，寻找一个半有序数组。每次都定位到数组的中间位置，判断是否后一位置大于当前位置，如果不是，则当前位置就是无序的起点。如果当前位置有序，则将数组一分为二，拆分后的数组继续执行此方法。

第六周学习了动态规划算法，按照我的理解，就是把大问题分解成每一个小问题，大问题的答案可以通过每个小问题的解得到，而最初始的小问题是可以轻松求解的，求得这个小问题的解后，可以递推到下一个问题的解。通过层层递推，最终求得大问题的解。
动态规划的关键是，确定起始问题，确定DP方程。

第七周学习了字典树，其优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。
基本性质：
1. 结点本身不存完整单词；
2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的
字符串；
3. 每个结点的所有子结点路径代表的字符都不相同。

第八周学习了二进制上的一系列操作，还有各种排序算法的分析。
布隆过滤器是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。
LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。
排序算法有
1. 比较类排序：
通过比较来决定元素间的相对次序，由于其时间复杂度不能突破
O(nlogn)，因此也称为非线性时间比较类排序。
2. 非比较类排序：
不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时
间下界，以线性时间运行，因此也称为线性时间非比较类排序。

第九周回顾了动态规划。
动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）
拥有共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解
动态规划原理都涉及到了重叠子问题，和最优子结构。
①最优子结构
用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。
②重叠子问题
如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。